import os
import time
import json
import requests
import argparse
import random
import hashlib
import shutil
import io
import zipfile
import re
import sys
import tempfile
from datetime import datetime

# API keys
MALWAREBAZAAR_API_KEY = "a7f5a8434edea24df954df7741636160c28"
HYBRID_ANALYSIS_API_KEY = "0bb1ttzma7069b5epmpvw04l17d0cfe8743xg1d5202aaf1e8caazkar433e7ad0"  # Replace with your actual key
HYBRID_ANALYSIS_SECRET = "d90e33727a4d4437499144c44ede618e7ec2689807a40b88"  # Secret for Hybrid Analysis

# Paths
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
TRAINING_DIR = os.path.join(BASE_DIR, "training_data")
MALICIOUS_DIR = os.path.join(TRAINING_DIR, "malicious")
EXISTING_DATA_DIR = os.path.join(os.path.dirname(BASE_DIR), "eng_final_data")

# Target malware families and their corresponding directories
MALWARE_FAMILIES = {
    "elf_miner": {
        "signatures": ["miner", "coinminer", "bitcoin", "monero", "xmr"],
        "tags": ["miner", "coinminer", "cryptominer"],
        "file_type": "elf",
        "hybrid_terms": ["linux miner", "elf miner", "linux coinminer", "linux cryptominer"]
    },
    "elf_berbew": {
        "signatures": ["berbew"],
        "tags": ["berbew", "trojan"],
        "file_type": "elf",
        "hybrid_terms": ["linux berbew", "elf berbew", "linux trojan", "elf trojan"]
    },
    "exe_loader": {
        "signatures": ["loader"],
        "tags": ["loader", "downloader"],
        "file_type": "exe",
        "hybrid_terms": ["windows loader", "exe loader", "windows downloader"]
    },
    "exe_dacic": {
        "signatures": ["dacic", "darkcloud"],
        "tags": ["dacic", "darkcloud"],
        "file_type": "exe",
        "hybrid_terms": ["windows dacic", "exe dacic", "windows darkcloud", "darkcloud malware"]
    }
}

# ===== MalwareBazaar API Functions =====

def query_malwarebazaar(query_type, query, limit=100):
    """Query MalwareBazaar for samples"""
    url = "https://mb-api.abuse.ch/api/v1/"
    
    data = {
        "query": query_type,
        "api_key": MALWAREBAZAAR_API_KEY,
        "limit": limit
    }
    
    if query_type == "get_taginfo":
        data["tag"] = query
    elif query_type == "get_siginfo":
        data["signature"] = query
    elif query_type == "get_file":
        data["sha256_hash"] = query
    elif query_type == "get_filetype":
        data["file_type"] = query
    
    try:
        response = requests.post(url, data=data)
        
        if response.status_code == 200:
            result = response.json()
            if result.get("query_status") == "ok":
                return {
                    "success": True,
                    "data": result.get("data", [])
                }
            else:
                return {
                    "success": False,
                    "error": result.get("query_status")
                }
        else:
            return {
                "success": False,
                "error": f"API error: {response.status_code}"
            }
    
    except Exception as e:
        return {
            "success": False,
            "error": str(e)
        }

def extract_zip_with_passwords(zip_content, destination_path, passwords=None):
    """
    Extract a ZIP file with password attempts.
    
    Args:
        zip_content: The content of the ZIP file as bytes
        destination_path: Path where the extracted file should be saved
        passwords: List of passwords to try (default: ["infected", "malware"])
    
    Returns:
        dict: Result of the extraction with success status and details
    """
    if passwords is None:
        passwords = ["infected", "malware"]
    
    # Create a temporary file to store the ZIP content
    with tempfile.NamedTemporaryFile(delete=False) as temp_file:
        temp_file.write(zip_content)
        temp_zip_path = temp_file.name
    
    try:
        # First try without password
        try:
            with zipfile.ZipFile(temp_zip_path) as zip_file:
                # Get the list of files in the ZIP
                file_list = zip_file.namelist()
                if not file_list:
                    return {"success": False, "error": "ZIP file is empty"}
                
                # Extract the first file (usually the malware sample)
                extracted_content = zip_file.read(file_list[0])
                with open(destination_path, 'wb') as f:
                    f.write(extracted_content)
                
                return {
                    "success": True,
                    "extracted_file": file_list[0],
                    "password_used": None
                }
        except zipfile.BadZipFile:
            return {"success": False, "error": "Not a valid ZIP file"}
        except RuntimeError as e:
            # Password required, try with passwords
            if "password required" in str(e).lower() or "encrypted" in str(e).lower():
                for password in passwords:
                    try:
                        with zipfile.ZipFile(temp_zip_path) as zip_file:
                            # Get the list of files in the ZIP
                            file_list = zip_file.namelist()
                            if not file_list:
                                continue
                            
                            # Extract the first file with password
                            extracted_content = zip_file.read(file_list[0], pwd=password.encode())
                            with open(destination_path, 'wb') as f:
                                f.write(extracted_content)
                            
                            return {
                                "success": True,
                                "extracted_file": file_list[0],
                                "password_used": password
                            }
                    except (RuntimeError, zipfile.BadZipFile) as e:
                        continue
                
                # If we get here, none of the passwords worked
                return {"success": False, "error": "Failed to extract with provided passwords"}
            else:
                # Some other RuntimeError
                return {"success": False, "error": str(e)}
    finally:
        # Clean up the temporary file
        try:
            os.unlink(temp_zip_path)
        except:
            pass

def download_sample_from_malwarebazaar(sha256_hash, destination_dir, file_extension):
    """Download a specific sample from MalwareBazaar"""
    url = "https://mb-api.abuse.ch/api/v1/"
    
    data = {
        "query": "get_file",
        "sha256_hash": sha256_hash,
        "api_key": MALWAREBAZAAR_API_KEY
    }
    
    try:
        response = requests.post(url, data=data)
        
        if response.status_code == 200:
            # Create destination directory if it doesn't exist
            os.makedirs(destination_dir, exist_ok=True)
            
            # Save file with appropriate extension
            file_path = os.path.join(destination_dir, f"{sha256_hash}.{file_extension}")
            
            # Check if the file is a ZIP file (MalwareBazaar returns samples as ZIP files)
            if response.content.startswith(b'PK'):
                print(f"    Downloaded sample is a ZIP file. Extracting...")
                
                # Try to extract the ZIP file with password attempts
                extract_result = extract_zip_with_passwords(response.content, file_path)
                
                if extract_result.get("success", False):
                    if extract_result.get("password_used"):
                        print(f"    Extracted {extract_result.get('extracted_file')} to {file_path} using password: {extract_result.get('password_used')}")
                    else:
                        print(f"    Extracted {extract_result.get('extracted_file')} to {file_path}")
                else:
                    print(f"    {extract_result.get('error', 'Unknown extraction error')}. Saving ZIP as is.")
                    with open(file_path, 'wb') as f:
                        f.write(response.content)
            else:
                # Not a ZIP file, save as is
                with open(file_path, 'wb') as f:
                    f.write(response.content)
            
            return {
                "success": True,
                "file_path": file_path
            }
        else:
            return {
                "success": False,
                "error": f"API error: {response.status_code}"
            }
    
    except Exception as e:
        return {
            "success": False,
            "error": str(e)
        }

def search_malwarebazaar_for_samples(family_name, family_info, limit=200):
    """Search for samples of a specific malware family on MalwareBazaar"""
    print(f"Searching MalwareBazaar for {family_name} samples...")
    
    file_hashes = []
    file_type = family_info["file_type"]
    
    # Strategy 1: Search by malware signatures
    if not file_hashes and family_info.get("signatures"):
        for signature in family_info["signatures"]:
            print(f"  Searching for samples with signature: {signature}")
            
            # Clean up signature (remove special characters)
            clean_signature = ''.join(c for c in signature if c.isalnum() or c.isspace()).strip()
            if not clean_signature:
                continue
            
            search_result = query_malwarebazaar("get_siginfo", clean_signature)
            
            if search_result.get("success", False):
                data = search_result.get("data", [])
                # Filter by file type
                filtered_data = [item for item in data if item.get("file_type", "").lower() == file_type.lower()]
                
                # Extract SHA256 hashes
                new_hashes = [item.get("sha256_hash") for item in filtered_data if item.get("sha256_hash")]
                file_hashes.extend(new_hashes)
                
                print(f"    Found {len(new_hashes)} samples with signature '{signature}'")
                
                if len(file_hashes) >= limit:
                    break
            else:
                print(f"    Error searching for signature '{signature}': {search_result.get('error', 'Unknown error')}")
                # Retry after 60 seconds if there was an API error
                if "API error" in search_result.get("error", ""):
                    print(f"    Retrying after 60 seconds...")
                    time.sleep(60)
                    search_result = query_malwarebazaar("get_siginfo", clean_signature)
                    if search_result.get("success", False):
                        data = search_result.get("data", [])
                        filtered_data = [item for item in data if item.get("file_type", "").lower() == file_type.lower()]
                        new_hashes = [item.get("sha256_hash") for item in filtered_data if item.get("sha256_hash")]
                        file_hashes.extend(new_hashes)
                        print(f"    Found {len(new_hashes)} samples with signature '{signature}' after retry")
    
    # Strategy 2: Search by tags
    if len(file_hashes) < limit and family_info.get("tags"):
        for tag in family_info["tags"]:
            print(f"  Searching for samples with tag: {tag}")
            
            search_result = query_malwarebazaar("get_taginfo", tag)
            
            if search_result.get("success", False):
                data = search_result.get("data", [])
                # Filter by file type
                filtered_data = [item for item in data if item.get("file_type", "").lower() == file_type.lower()]
                
                # Extract SHA256 hashes
                new_hashes = [item.get("sha256_hash") for item in filtered_data if item.get("sha256_hash")]
                # Only add hashes that aren't already in our list
                new_hashes = [h for h in new_hashes if h not in file_hashes]
                file_hashes.extend(new_hashes)
                
                print(f"    Found {len(new_hashes)} additional samples with tag '{tag}'")
                
                if len(file_hashes) >= limit:
                    break
            else:
                print(f"    Error searching for tag '{tag}': {search_result.get('error', 'Unknown error')}")
                # Retry after 60 seconds if there was an API error
                if "API error" in search_result.get("error", ""):
                    print(f"    Retrying after 60 seconds...")
                    time.sleep(60)
                    search_result = query_malwarebazaar("get_taginfo", tag)
                    if search_result.get("success", False):
                        data = search_result.get("data", [])
                        filtered_data = [item for item in data if item.get("file_type", "").lower() == file_type.lower()]
                        new_hashes = [item.get("sha256_hash") for item in filtered_data if item.get("sha256_hash")]
                        new_hashes = [h for h in new_hashes if h not in file_hashes]
                        file_hashes.extend(new_hashes)
                        print(f"    Found {len(new_hashes)} additional samples with tag '{tag}' after retry")
    
    # Strategy 3: Search by file type as a fallback
    if len(file_hashes) < limit:
        print(f"  Searching for samples with file type: {file_type}")
        
        search_result = query_malwarebazaar("get_filetype", file_type)
        
        if search_result.get("success", False):
            data = search_result.get("data", [])
            
            # Extract SHA256 hashes
            new_hashes = [item.get("sha256_hash") for item in data if item.get("sha256_hash")]
            # Only add hashes that aren't already in our list
            new_hashes = [h for h in new_hashes if h not in file_hashes]
            file_hashes.extend(new_hashes)
            
            print(f"    Found {len(new_hashes)} additional samples with file type '{file_type}'")
        else:
            print(f"    Error searching for file type '{file_type}': {search_result.get('error', 'Unknown error')}")
            # Retry after 60 seconds if there was an API error
            if "API error" in search_result.get("error", ""):
                print(f"    Retrying after 60 seconds...")
                time.sleep(60)
                search_result = query_malwarebazaar("get_filetype", file_type)
                if search_result.get("success", False):
                    data = search_result.get("data", [])
                    new_hashes = [item.get("sha256_hash") for item in data if item.get("sha256_hash")]
                    new_hashes = [h for h in new_hashes if h not in file_hashes]
                    file_hashes.extend(new_hashes)
                    print(f"    Found {len(new_hashes)} additional samples with file type '{file_type}' after retry")
    
    # Limit to the requested number of samples
    file_hashes = file_hashes[:limit]
    
    print(f"  Found a total of {len(file_hashes)} samples for {family_name} on MalwareBazaar")
    
    return file_hashes

def query_hybrid_analysis(search_terms, file_type=None, limit=100):
    """Query Hybrid Analysis for samples"""
    url = "https://www.hybrid-analysis.com/api/v2/search/hash"
    
    headers = {
        "api-key": HYBRID_ANALYSIS_API_KEY,
        "api-secret": HYBRID_ANALYSIS_SECRET,
        "User-Agent": "Falcon Sandbox",
        "Accept": "application/json"
    }
    
    params = {
        "query": search_terms,
        "limit": limit
    }
    
    try:
        response = requests.get(url, headers=headers, params=params)
        
        if response.status_code == 200:
            result = response.json()
            if "result" in result:
                # Filter by file type if specified
                if file_type:
                    filtered_data = [item for item in result["result"] if 
                                    (file_type.lower() == "elf" and item.get("environment_description", "").lower().startswith("linux")) or
                                    (file_type.lower() == "exe" and item.get("environment_description", "").lower().startswith("windows"))]
                    return {
                        "success": True,
                        "data": filtered_data
                    }
                else:
                    return {
                        "success": True,
                        "data": result["result"]
                    }
            else:
                return {
                    "success": False,
                    "error": "No results found"
                }
        else:
            return {
                "success": False,
                "error": f"API error: {response.status_code}"
            }
    
    except Exception as e:
        return {
            "success": False,
            "error": str(e)
        }

def download_sample_from_hybrid_analysis(sha256_hash, destination_dir, file_extension):
    """Download a specific sample from Hybrid Analysis"""
    url = f"https://www.hybrid-analysis.com/api/v2/overview/{sha256_hash}/sample"
    
    headers = {
        "api-key": HYBRID_ANALYSIS_API_KEY,
        "api-secret": HYBRID_ANALYSIS_SECRET,
        "User-Agent": "Falcon Sandbox",
        "Accept": "application/octet-stream"
    }
    
    try:
        response = requests.get(url, headers=headers)
        
        if response.status_code == 200:
            # Create destination directory if it doesn't exist
            os.makedirs(destination_dir, exist_ok=True)
            
            # Save file with appropriate extension
            file_path = os.path.join(destination_dir, f"{sha256_hash}.{file_extension}")
            
            # Check if the file is a ZIP file
            if response.content.startswith(b'PK'):
                print(f"    Downloaded sample is a ZIP file. Extracting...")
                
                # Try to extract the ZIP file with password attempts
                extract_result = extract_zip_with_passwords(response.content, file_path)
                
                if extract_result.get("success", False):
                    if extract_result.get("password_used"):
                        print(f"    Extracted {extract_result.get('extracted_file')} to {file_path} using password: {extract_result.get('password_used')}")
                    else:
                        print(f"    Extracted {extract_result.get('extracted_file')} to {file_path}")
                else:
                    print(f"    {extract_result.get('error', 'Unknown extraction error')}. Saving ZIP as is.")
                    with open(file_path, 'wb') as f:
                        f.write(response.content)
            else:
                # Not a ZIP file, save as is
                with open(file_path, 'wb') as f:
                    f.write(response.content)
            
            return {
                "success": True,
                "file_path": file_path
            }
        else:
            return {
                "success": False,
                "error": f"API error: {response.status_code}"
            }
    
    except Exception as e:
        return {
            "success": False,
            "error": str(e)
        }

def search_hybrid_analysis_for_samples(family_name, family_info, limit=200):
    """Search for samples of a specific malware family on Hybrid Analysis"""
    print(f"Searching Hybrid Analysis for {family_name} samples...")
    
    file_hashes = []
    file_type = family_info["file_type"]
    
    # Search using each of the hybrid search terms
    if family_info.get("hybrid_terms"):
        for search_term in family_info["hybrid_terms"]:
            print(f"  Searching for samples with term: {search_term}")
            
            search_result = query_hybrid_analysis(search_term, file_type=file_type)
            
            if search_result.get("success", False):
                data = search_result.get("data", [])
                
                # Extract SHA256 hashes
                new_hashes = [item.get("sha256") for item in data if item.get("sha256")]
                # Only add hashes that aren't already in our list
                new_hashes = [h for h in new_hashes if h not in file_hashes]
                file_hashes.extend(new_hashes)
                
                print(f"    Found {len(new_hashes)} samples with search term '{search_term}'")
                
                if len(file_hashes) >= limit:
                    break
            else:
                print(f"    Error searching for term '{search_term}': {search_result.get('error', 'Unknown error')}")
                # Retry after 60 seconds if there was an API error
                if "API error" in search_result.get("error", ""):
                    print(f"    Retrying after 60 seconds...")
                    time.sleep(60)
                    search_result = query_hybrid_analysis(search_term, file_type=file_type)
                    if search_result.get("success", False):
                        data = search_result.get("data", [])
                        new_hashes = [item.get("sha256") for item in data if item.get("sha256")]
                        new_hashes = [h for h in new_hashes if h not in file_hashes]
                        file_hashes.extend(new_hashes)
                        print(f"    Found {len(new_hashes)} samples with search term '{search_term}' after retry")
    
    # Limit to the requested number of samples
    file_hashes = file_hashes[:limit]
    
    print(f"  Found a total of {len(file_hashes)} samples for {family_name} on Hybrid Analysis")
    
    return file_hashes

# ===== Synthetic Sample Generation =====

def generate_synthetic_samples(family_name, family_info, template_dir, num_samples=100):
    """Generate synthetic samples based on existing samples"""
    print(f"Generating {num_samples} synthetic samples for {family_name}...")
    
    # Get list of existing samples to use as templates
    template_files = []
    for root, _, files in os.walk(template_dir):
        for file in files:
            if file.endswith(f".{family_info['file_type']}"):
                template_files.append(os.path.join(root, file))
    
    if not template_files:
        print(f"  No template files found for {family_name}. Cannot generate synthetic samples.")
        return []
    
    print(f"  Found {len(template_files)} template files")
    
    # Create directory for synthetic samples
    synthetic_dir = os.path.join(template_dir, "synthetic")
    os.makedirs(synthetic_dir, exist_ok=True)
    
    generated_files = []
    
    # For each synthetic sample to generate
    for i in range(num_samples):
        # Select a random template file
        template_file = random.choice(template_files)
        template_basename = os.path.basename(template_file)
        
        # Read the file content
        with open(template_file, 'rb') as f:
            content = bytearray(f.read())
        
        # Create a copy of the content
        synthetic_content = bytearray(content)
        
        # Apply random modifications
        # 1. Modify a small percentage of bytes (1-5%)
        num_bytes_to_modify = max(1, int(len(synthetic_content) * (0.01 + 0.04 * random.random())))
        for _ in range(num_bytes_to_modify):
            idx = random.randint(0, len(synthetic_content) - 1)
            synthetic_content[idx] = random.randint(0, 255)
        
        # 2. Insert a small number of random bytes (0-2%)
        if len(synthetic_content) > 100:  # Only if file is large enough
            num_bytes_to_insert = int(len(synthetic_content) * (0.02 * random.random()))
            for _ in range(num_bytes_to_insert):
                idx = random.randint(0, len(synthetic_content) - 1)
                synthetic_content.insert(idx, random.randint(0, 255))
        
        # 3. Remove a small number of bytes (0-2%)
        if len(synthetic_content) > 100:  # Only if file is large enough
            num_bytes_to_remove = int(len(synthetic_content) * (0.02 * random.random()))
            for _ in range(num_bytes_to_remove):
                if len(synthetic_content) > 1:  # Ensure we don't remove all bytes
                    idx = random.randint(0, len(synthetic_content) - 1)
                    del synthetic_content[idx]
        
        # Generate a unique hash for the synthetic sample
        hash_obj = hashlib.sha256()
        hash_obj.update(synthetic_content)
        synthetic_hash = hash_obj.hexdigest()
        
        # Save the synthetic sample
        synthetic_file_path = os.path.join(synthetic_dir, f"{synthetic_hash}.{family_info['file_type']}")
        
        with open(synthetic_file_path, 'wb') as f:
            f.write(synthetic_content)
        
        generated_files.append(synthetic_file_path)
        print(f"    Created synthetic sample {i+1}/{num_samples}: {synthetic_file_path}")
    
    print(f"  Generated {len(generated_files)} synthetic samples for {family_name}")
    
    return generated_files

# ===== Existing Files Functions =====

def get_existing_hashes():
    """Get SHA256 hashes of files that already exist in the eng_final_data directory"""
    existing_hashes = []
    
    if os.path.exists(EXISTING_DATA_DIR):
        print(f"Scanning existing files in {EXISTING_DATA_DIR}...")
        for filename in os.listdir(EXISTING_DATA_DIR):
            # Extract hash from filename (assuming filename format is hash.extension)
            if '.' in filename:
                file_hash = filename.split('.')[0]
                # Verify it's a valid SHA256 hash (64 hex characters)
                if len(file_hash) == 64 and all(c in '0123456789abcdef' for c in file_hash.lower()):
                    existing_hashes.append(file_hash.lower())
        
        print(f"Found {len(existing_hashes)} existing files with valid SHA256 hashes")
    else:
        print(f"Warning: Existing data directory {EXISTING_DATA_DIR} not found")
    
    return existing_hashes

# ===== Main Download Functions =====

def download_samples(family_name, family_info, samples_per_family=200, resume=False, use_hybrid=True, generate_synthetic=True):
    """Download samples for a specific malware family"""
    print(f"Downloading samples for {family_name}...")
    
    # Get existing hashes to avoid downloading duplicates
    existing_hashes = get_existing_hashes()
    
    # Create directory for this family
    family_dir = os.path.join(MALICIOUS_DIR, family_name)
    os.makedirs(family_dir, exist_ok=True)
    
    # Create progress tracking file
    progress_file = os.path.join(MALICIOUS_DIR, f"{family_name}_progress.json")
    progress = {}
    
    if resume and os.path.exists(progress_file):
        with open(progress_file, 'r') as f:
            progress = json.load(f)
        print(f"  Resuming download from progress file")
    
    # Initialize progress if needed
    if 'mb_file_hashes' not in progress:
        progress['mb_file_hashes'] = []
    
    if 'ha_file_hashes' not in progress:
        progress['ha_file_hashes'] = []
    
    if 'downloaded_hashes' not in progress:
        progress['downloaded_hashes'] = []
    
    if 'synthetic_files' not in progress:
        progress['synthetic_files'] = []
    
    # Step 1: Search MalwareBazaar if not already done
    if not progress['mb_file_hashes']:
        mb_file_hashes = search_malwarebazaar_for_samples(family_name, family_info, limit=samples_per_family)
        # Filter out hashes that already exist locally
        mb_file_hashes = [h for h in mb_file_hashes if h.lower() not in existing_hashes]
        print(f"  After filtering out existing files, {len(mb_file_hashes)} unique MalwareBazaar samples remain")
        progress['mb_file_hashes'] = mb_file_hashes
        
        # Save progress
        with open(progress_file, 'w') as f:
            json.dump(progress, f, indent=2)
    
    # Step 2: Search Hybrid Analysis if enabled and if we need more samples
    if use_hybrid and len(progress['mb_file_hashes']) < samples_per_family and not progress['ha_file_hashes']:
        remaining_samples = samples_per_family - len(progress['mb_file_hashes'])
        ha_file_hashes = search_hybrid_analysis_for_samples(family_name, family_info, limit=remaining_samples)
        # Remove any duplicates with MalwareBazaar hashes or existing files
        ha_file_hashes = [h for h in ha_file_hashes if h not in progress['mb_file_hashes'] and h.lower() not in existing_hashes]
        print(f"  After filtering out existing files, {len(ha_file_hashes)} unique Hybrid Analysis samples remain")
        progress['ha_file_hashes'] = ha_file_hashes
        
        # Save progress
        with open(progress_file, 'w') as f:
            json.dump(progress, f, indent=2)
    
    # Step 3: Download samples from MalwareBazaar
    mb_file_hashes = progress['mb_file_hashes']
    downloaded_hashes = progress['downloaded_hashes']
    
    for i, file_hash in enumerate(mb_file_hashes):
        # Skip if already downloaded
        if file_hash in downloaded_hashes:
            print(f"  Skipping MalwareBazaar sample {i+1}/{len(mb_file_hashes)}: {file_hash} (already downloaded)")
            continue
        
        print(f"  Downloading MalwareBazaar sample {i+1}/{len(mb_file_hashes)}: {file_hash}")
        
        download_result = download_sample_from_malwarebazaar(file_hash, family_dir, family_info["file_type"])
        
        if not download_result.get("success", False):
            print(f"    Error downloading sample: {download_result.get('error', 'Unknown error')}")
            # Retry after 60 seconds if there was an API error
            if "API error" in download_result.get("error", ""):
                print(f"    Retrying after 60 seconds...")
                time.sleep(60)
                download_result = download_sample_from_malwarebazaar(file_hash, family_dir, family_info["file_type"])
                if not download_result.get("success", False):
                    print(f"    Error downloading sample after retry: {download_result.get('error', 'Unknown error')}")
                    continue
        
        print(f"    Downloaded to {download_result.get('file_path')}")
        # Update progress
        downloaded_hashes.append(file_hash)
        progress['downloaded_hashes'] = downloaded_hashes
        
        # Save progress after each download
        with open(progress_file, 'w') as f:
            json.dump(progress, f, indent=2)
    
    # Step 4: Download samples from Hybrid Analysis if enabled
    if use_hybrid:
        ha_file_hashes = progress['ha_file_hashes']
        
        for i, file_hash in enumerate(ha_file_hashes):
            # Skip if already downloaded
            if file_hash in downloaded_hashes:
                print(f"  Skipping Hybrid Analysis sample {i+1}/{len(ha_file_hashes)}: {file_hash} (already downloaded)")
                continue
            
            print(f"  Downloading Hybrid Analysis sample {i+1}/{len(ha_file_hashes)}: {file_hash}")
            
            download_result = download_sample_from_hybrid_analysis(file_hash, family_dir, family_info["file_type"])
            
            if not download_result.get("success", False):
                print(f"    Error downloading sample: {download_result.get('error', 'Unknown error')}")
                # Retry after 60 seconds if there was an API error
                if "API error" in download_result.get("error", ""):
                    print(f"    Retrying after 60 seconds...")
                    time.sleep(60)
                    download_result = download_sample_from_hybrid_analysis(file_hash, family_dir, family_info["file_type"])
                    if not download_result.get("success", False):
                        print(f"    Error downloading sample after retry: {download_result.get('error', 'Unknown error')}")
                        continue
            
            print(f"    Downloaded to {download_result.get('file_path')}")
            # Update progress
            downloaded_hashes.append(file_hash)
            progress['downloaded_hashes'] = downloaded_hashes
            
            # Save progress after each download
            with open(progress_file, 'w') as f:
                json.dump(progress, f, indent=2)
    
    # Step 5: Generate synthetic samples if needed and enabled
    total_real_samples = len(downloaded_hashes)
    if generate_synthetic and total_real_samples < samples_per_family and total_real_samples > 0:
        # Only generate synthetic samples if we have at least one real sample to use as a template
        remaining_samples = samples_per_family - total_real_samples
        
        # Check if we've already generated synthetic samples
        if not progress['synthetic_files']:
            synthetic_files = generate_synthetic_samples(family_name, family_info, family_dir, num_samples=remaining_samples)
            progress['synthetic_files'] = synthetic_files
            
            # Save progress
            with open(progress_file, 'w') as f:
                json.dump(progress, f, indent=2)
    
    # Calculate total samples (real + synthetic)
    total_samples = len(downloaded_hashes) + len(progress['synthetic_files'])
    
    print(f"  Downloaded {len(downloaded_hashes)} real samples for {family_name}")
    print(f"  Generated {len(progress['synthetic_files'])} synthetic samples for {family_name}")
    print(f"  Total: {total_samples}/{samples_per_family} samples for {family_name}")
    
    return total_samples

def main():
    """Main function with command-line argument parsing"""
    parser = argparse.ArgumentParser(description="Download malware samples from MalwareBazaar and Hybrid Analysis")
    parser.add_argument("--samples", type=int, default=200, help="Number of samples to download per family")
    parser.add_argument("--resume", action="store_true", help="Resume download from previous progress")
    parser.add_argument("--mb-api-key", type=str, help="MalwareBazaar API key")
    parser.add_argument("--ha-api-key", type=str, help="Hybrid Analysis API key")
    parser.add_argument("--family", type=str, help="Specific family to download (default: all)")
    parser.add_argument("--no-hybrid", action="store_true", help="Disable Hybrid Analysis API")
    parser.add_argument("--no-synthetic", action="store_true", help="Disable synthetic sample generation")
    
    args = parser.parse_args()
    
    # Set API keys if provided
    global MALWAREBAZAAR_API_KEY, HYBRID_ANALYSIS_API_KEY
    if args.mb_api_key:
        MALWAREBAZAAR_API_KEY = args.mb_api_key
    if args.ha_api_key:
        HYBRID_ANALYSIS_API_KEY = args.ha_api_key
    
    # Create main directories
    os.makedirs(TRAINING_DIR, exist_ok=True)
    os.makedirs(MALICIOUS_DIR, exist_ok=True)
    
    # Download samples for each family
    total_downloaded = 0
    
    if args.family and args.family in MALWARE_FAMILIES:
        # Download samples for a specific family
        family_name = args.family
        family_info = MALWARE_FAMILIES[family_name]
        total_downloaded += download_samples(
            family_name, 
            family_info, 
            samples_per_family=args.samples, 
            resume=args.resume,
            use_hybrid=not args.no_hybrid,
            generate_synthetic=not args.no_synthetic
        )
    else:
        # Download samples for all families
        for family_name, family_info in MALWARE_FAMILIES.items():
            total_downloaded += download_samples(
                family_name, 
                family_info, 
                samples_per_family=args.samples, 
                resume=args.resume,
                use_hybrid=not args.no_hybrid,
                generate_synthetic=not args.no_synthetic
            )
    
    print(f"Download complete. Total samples downloaded/generated: {total_downloaded}")

if __name__ == "__main__":
    main()
